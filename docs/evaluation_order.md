# 求值顺序
<<<<<<< HEAD
 
=======

>>>>>>> eb8043c8c6789df07c801a4dc1f1868bc299fc30
- 定义
    * 几乎所有 C++ 运算符的求值顺序（包括函数调用表达式中的函数参数求值顺序和任何表达式中子表达式的求值顺序）都是未指定的。编译器能以任何顺序求值，并可以在再次求值相同表达式时选择另一顺序。
    * 这里需要区分的是运算符的结合性和求值顺序：表达式 f1() + f2() + f3() 由于 operator+ 的从左到右结合性分析为 (f1() + f2()) + f3() ，但运行时对 f3 的函数调用可能首先、最后，或在 f1() 和 f2() 之间求值。
- 规则
    * 虽然在很多地方都是没有求值顺序的，但是也有一些特殊的规定，求值顺序一般出现在各种面试题中，有时候，我们不知道求值顺序，那么这些问题就会变得比较难理解。
    * 一般定义一个`先序于(sequenced_before)`顺序来表示，它是一种具有反对称，可传递的成对关系
        1. `完整表达式`的值的计算和副效应都先序于下个完整表达式的每个值的计算和副效应。这一条比较难理解，我们需要知道哪些是完整表达式，
        2. 任何运算符的`运算数`的值计算（但非副效应）先序于`运算符结果`的值计算（但非副效应）。这个好理解，没有运算数，就没有办法计算结果值
        3. 调用函数时（无论函数是否内联，无论是否使用显式函数调用语法），与任何`参数表达式`或与指代被调用函数的`后缀表达式`关联的每个值计算和副效应，都先序于被调用`函数体内的每个表达式或语句`的求值。也就是说函数的参数总是先于函数体内部表达式求值。
        4. 内建`后自增`与`后自减`运算符的`值计算`先序于其`副效应`。
        5. 内建`前自增`与`前自减`运算符的`副效应`先序于其`值计算`。这两条就是我们经常说的++,--操作的顺序，初学的时候，我们经常出现疑惑。这里我们要明白，任何一个求值其实都包含了一个`值计算`和一个`副效应`，值计算就确定表达式的返回值，而副效应则表示一些访问（读或写） volatile 泛左值所指代的对象，修改（写入）对象、调用库 I/O 函数或调用任何做这些操作的函数。我们看到前置++的值计算是返回结果，副效应是自增，根据规则，就有了先自增,然后返回。而后置++则是先返回再自增。
        6. 内建`逻辑与运算符 &&` 和内建`逻辑或运算符` || 的`第一`（左）运算数的每个值计算和副效应，先序于`第二`（右）运算数的每个值计算和副效应。这个规则就是我们经常所说的逻辑运算符的懒惰性。
        7. 与`条件运算符 ?:` 中的第一表达式关联的每个值计算和副效应，都先序于与第二或第三表达式关联的每个值计算和副效应。这个好理解。
        8. 内建`赋值运算符`和所有内建`复合赋值运算符`的副效应（修改左参数）后序于左右参数的值计算（但非副效应），并先序于赋值表达式的值计算（即先于返回被修改对象的引用）。
        9. 内建`逗号运算符` , 的`第一`（左）参数的每个值计算和副效应先序于`第二`（右）参数的每个值计算和副效应。
        10. `列表初始化`中，给定初始化器子句的每个值计算和副效应先序于与在初始化器的花括号逗号分隔列表中后随它的任何初始化器子句关联的值计算和副效应。
        11. 既不先序于又不后序于另一函数调用的函数调用是非确定顺序的（程序必须表现为如同组成不同函数调用的 CPU 指令决不会交错，即使函数被内联）。
        12. `对分配函数（ operator new ）的调用`相对于 new 表达式中`构造函数参数的求值`为`非确定顺序` (C++17 前)先序 (C++17 起)。
        13. 从函数返回时，作为求值函数调用结果的`临时量的复制初始化`先序于在 return 语句的运算数结尾的`所有临时量析构`，也就是先序于环绕 return 语句的块的所有局部变量的析构。这条规则保证了我们可以返回一个临时变量。
        14. 函数调用表达式中，指名函数的表达式先序于每个参数表达式和每个默认参数。
        15. 函数调用表达式中，每个形参的初始化的值计算和副效应相对于任何其他形参的初始化的值计算和副效应为`非确定顺序`。
        16. 用运算符记号调用时，每个重载的运算符遵循其所重载的内建运算符的定序规则。
        17. 下标表达式 E1[E2] 中， E1 的每个值计算和副效应先序于 E2 的每个值计算和副效应。
        18. 指向成员指针表达式 E1.*E2 或 E1->*E2 中， E1 v的每个值计算和副效应都先序于 E2 的每个值计算和副效应（除非 E1 的动态类型不含 E2 所指的成员）。
        19. 移位运算符表达式 E1<<E2 和 E1>>E2 中， E1 的每个值计算和副效应先序于 E2 的每个值计算和副效应。
        20. 每个简单赋值表达式 E1=E2 和每个复合赋值表达式 E1@=E2 中， E2 的每个值计算和副效应先序于 E1 的每个值计算和副效应。
        21. 括号初始化器中表达式的逗号分隔列表中的每个表达式如同函数调用一般求值（非确定顺序）。
    * 有了这几个规则时候，我们基本可以去分析一个复杂表达式中的各个子表达式的执行顺序了，但是也有一些未定义的行为：
        1.  若标量对象上的副效应相对同一标量对象上的另一副效应无顺序，则行为未定义
        ``` C++
        n = ++i + i++;
        ```
        2.  若标量对象上的副效应相对使用同一标量对象的值的值计算无顺序，则行为未定义。
        ``` C++
        n = ++i + i;
        ```
        这些表达式本质上是没有定义的，因为在运算符左右的操作数的执行顺序是不确定的，这就导致了同一个表达式在不同的环境中，或者不同的编译器中得到的结果可能是不同的，那么既然得到的结果不是确定的，那么应该在编码的时候尽量避免这种情况。
    * 序列点(sequence point)：执行序列中的点，在该点所有来自序列中先求值的副效应均已完成，而后续求值副效应都未开始。
        1. 每个完整表达式结尾都有一个序列点，典型的就是一个`;`之后;
        2. 调用函数时（无论该函数是否内联，无论是否使用函数调用语法），所有函数参数的求值（若存在）后有一个序列点，它在函数体内的任何表达式或语句执行前发生，这句话就是说函数的参数求值总是先于函数体内部的表达式求值。
        3. 复制函数返回值后，和函数外任何语句的执行前有一个序列点。
        4. 一旦函数执行开始，则在被调用函数完成前，不求值来自调用方函数的表达式,这句话的意思就是说函数不能交错。一个函数没有执行完毕(其中的所有语句的值计算和副效应)，那么调用它的函数则不能执行任何的求值工作。
        5. 每个使用内建（非重载）运算符的下列四种表达式的求值中，表达式 a 的求值后有一个序列点。
---
| 操作 | 描述 |
| ------ | ------------------------------------------ |
| a && b | 表示a之后有一个序列点，结合先序规则的第6条 |
| a &#124&#124 b | 表示a之后有一个序列点，结合先序规则的第6条 |
| a ? b : c | 表示a之后有一个序列点，结合先序规则的第7条 |
| a, b | 表示a之后有一个序列点，结合先序规则的第9条 |
---
    * 未定义行为
        1. 前后序列点之间，至多可以修改标量对象的存储值一次，否则行为未定义
        ``` C++
        f(++i, ++i);
        f(i = -1, i = -1);
        i = ++i + i++;  //这些表达式中对一个标量对象都修改了两次以上，所以行为未定义
        ```
        2. 前后序列点之间，访问表达式求值所修改的标量对象的先前值，必须只为确定要存储的值，若以任何其他方式访问，则行为未定义。
        ``` C++
        cout << i << i++;
        a[i] = i++;
        ```



